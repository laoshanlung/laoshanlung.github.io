---
layout: post
title:  Use transclusion to implement template blocks in Angular
date:   2015-07-18 21:42:30
tags: javascript angular
---

Transclusion can be very confusing at first but when I get to know the basic concept of it in Angular, things get more and more interesting. With the use of `transclude` in directives, I can implement a lot of cool stuf, one of those things is to have a directive that accepts different blocks of content.

It is similar to the concept of blocks in many template engines such as  Jinja2 in Python or Swig in Nodejs. The use case for this kind of structure is to provide a basic template and accept custom markup in order to build the final output. In this post, I will skip the basic concept of transclusion in Angular because it has been explained in many places.

Few weeks ago, I wanted to have a popover (the one included in [Bootstrap](http://getbootstrap.com/javascript/#popovers)). The problem was that a popover component consists of 2 parts, the trigger (button, link etc...) and the actual popover content. I needed to put the popover component in a table generated by `ng-repeat` and use different text for the trigger and different data for the content based on the current item. At first, I was thinking about a specific directive to just show what needs to be shown in this particular table

{% highlight html %}
{% raw  %}
<specific-popover trigger-text="{{ item.name }}"
                  content-text="{{ item.name }}">
</specific-popover>
{% endraw  %}
{% endhighlight %}

Well, it worked, but I didn't like it because if I want to have a different markup for the content and/or the trigger element for another table, I need to implement a new directive and copy/paste most stuff from `specific-popover`. It is against D.R.Y principle. Then, I came up with a simple solution using transclusion.

{% highlight html %}
{% raw  %}
<general-popover>
    <popover-trigger><button class="btn btn-primary btn-xs">{{ item.name }}</button></popover-trigger>
    <popover-content>
        <h1>Hello! {{ item.name }}</h1>
    </popover-content>
</general-popover>
{% endraw  %}
{% endhighlight %}

It is longer but it's worth the extra typing effort. With this directive, I can reuse it whenever I need a popover. All I need to do is to provide the suitable templates for the trigger and the content part. In fact, this kind of structure has been used a lot, for example in [ui-select](https://github.com/angular-ui/ui-select), we have `ui-select-match` and `ui-select-choices` nested inside the main `ui-select` directive.

## The parent directive

{% highlight javascript %}
angular.module('myapp').directive('generalPopover', function() {

    return {
        controller: function($scope, $element) {
            var self = this;

            self.setTrigger = setTrigger;
            self.getTrigger = getTrigger;
            self.setContent = setContent;
            self.getContent = getContent;

            function setTrigger(elm) {
                self.popoverTriggerElm = elm;
            }

            function getTrigger() {
                return self.popoverTriggerElm;
            }

            function setContent(elm) {
                self.popoverContent = elm;
            }

            function getContent() {
                return self.popoverContent;
            }
        },
        link: function($scope, $element, $attrs, controller) {
            var triggerElm = controller.getTrigger();
            $element.append(triggerElm);

            $scope.$watch($attrs.options, function(newValue) {
                if (triggerElm.popover) {
                    triggerElm.popover('destroy');
                }

                triggerElm.popover({
                    html: true,
                    content: controller.getContent(),
                    placement: newValue.placement || 'bottom',
                    trigger: newValue.trigger || 'click'
                });
            });

            $scope.$on('$destroy', function() {
                triggerElm.popover('destroy');
            });
        }
    };

});
{% endhighlight %}

There is nothing special about this directive, the controller exposes several methods to get/set the content and the trigger element. Then `$watch` is used to monitor changes happened to the provided `options`. I don't use isolate scope or child scope because later on the other directives, I need to compile them against the current scope to use existing variables and functions from the outer scope. In this simple implementation, I just destroy the old popover and create a new one whenever there are changes detected.

## The content and trigger

{% highlight javascript %}
app.module('myapp').directive('popoverTrigger', function() {

    return {
        require: '^generalPopover',
        transclude: true,
        link: function($scope, $element, $attrs, ctrl, $transclude) {
            $transclude($scope, function(clone) {
                ctrl.setTrigger(clone);
            });
        }
    };

}).directive('popoverContent', function() {

    return {
        require: '^generalPopover',
        transclude: true,
        link: function($scope, $element, $attrs, ctrl, $transclude) {
            $transclude($scope, function(clone) {
                ctrl.setContent(clone);
            });
        }
    };

});
{% endhighlight %}

Those 2 directives are almost identical, the only difference is that they call different methods from the parent controller to set the content. Because of the way angular processes nested directives, we can safely process and pass the content from child directives to parent directive. In this case, the process is as following

- Call controller of `generalPopover`
- Call link of `popoverTrigger` and pass the controller instance of `generalPopover` due to the `require` attribute
- Call link of `popoverContent` and pass the controller instance of `generalPopover` due to the `require` attribute
- The link functions of child directives then process the transcluded content and pass it to `generalPopover` through `setTrigger` and `setContent`
- Call link of `generalPopover` and start the final rendering process using the transcluded content passed by `popoverTrigger` and `popoverContent`

There is one thing to note here is how all 3 directives work in the same scope. This enables the content and the trigger to access all the variables and functions of the outer scope.

This is just a naive implementation that I put together to demonstrate the solution. There are other better solutions such as [angular-material](https://material.angularjs.org/latest/#/) which uses this kind of structure a lot.